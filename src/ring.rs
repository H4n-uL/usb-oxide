//! TRB ring buffer structures for xHCI.

use crate::{Dma, Result, UsbError};

use core::marker::PhantomData;

/// Transfer Request Block (TRB) - 16 bytes aligned.
///
/// The fundamental data structure used for communication between
/// software and the xHCI controller.
#[repr(C, align(16))]
#[derive(Clone, Copy, Default)]
pub struct Trb {
    /// Parameter field (address or immediate data)
    pub param: u64,
    /// Status field (transfer length, completion code)
    pub status: u32,
    /// Control field (TRB type, flags)
    pub control: u32,
}

impl Trb {
    /// Creates a new zeroed TRB.
    pub const fn new() -> Self {
        Self {
            param: 0,
            status: 0,
            control: 0,
        }
    }

    /// Sets the cycle bit.
    pub fn set_cycle(&mut self, cycle: bool) {
        if cycle {
            self.control |= 1;
        } else {
            self.control &= !1;
        }
    }

    /// Returns the cycle bit.
    pub fn cycle(&self) -> bool {
        self.control & 1 != 0
    }

    /// Returns the TRB type.
    pub fn trb_type(&self) -> u8 {
        ((self.control >> 10) & 0x3f) as u8
    }

    /// Returns the completion code.
    pub fn completion_code(&self) -> u8 {
        ((self.status >> 24) & 0xff) as u8
    }

    /// Returns the slot ID.
    pub fn slot_id(&self) -> u8 {
        ((self.control >> 24) & 0xff) as u8
    }

    /// Returns the endpoint ID.
    pub fn endpoint_id(&self) -> u8 {
        ((self.control >> 16) & 0x1f) as u8
    }

    /// Returns the transfer length.
    pub fn transfer_length(&self) -> u32 {
        self.status & 0x1ffff
    }
}

/// TRB type codes as defined in the xHCI specification.
pub mod trb_type {
    // Transfer TRBs (used on Transfer Rings)
    /// Normal TRB - Used for bulk and interrupt transfers
    pub const NORMAL: u32 = 1;
    /// Setup Stage TRB - Control transfer setup stage
    pub const SETUP: u32 = 2;
    /// Data Stage TRB - Control transfer data stage
    pub const DATA: u32 = 3;
    /// Status Stage TRB - Control transfer status stage
    pub const STATUS: u32 = 4;
    /// Isoch TRB - Isochronous transfer
    pub const ISOCH: u32 = 5;
    /// Link TRB - Links to another segment
    pub const LINK: u32 = 6;
    /// Event Data TRB - Generate event with immediate data
    pub const EVENT_DATA: u32 = 7;
    /// No Op TRB (Transfer) - No operation on transfer ring
    pub const NO_OP: u32 = 8;

    // Command TRBs (used on Command Ring)
    /// Enable Slot Command
    pub const ENABLE_SLOT: u32 = 9;
    /// Disable Slot Command
    pub const DISABLE_SLOT: u32 = 10;
    /// Address Device Command
    pub const ADDRESS_DEVICE: u32 = 11;
    /// Configure Endpoint Command
    pub const CONFIGURE_ENDPOINT: u32 = 12;
    /// Evaluate Context Command
    pub const EVALUATE_CONTEXT: u32 = 13;
    /// Reset Endpoint Command
    pub const RESET_ENDPOINT: u32 = 14;
    /// Stop Endpoint Command
    pub const STOP_ENDPOINT: u32 = 15;
    /// Set TR Dequeue Pointer Command
    pub const SET_TR_DEQUEUE: u32 = 16;
    /// Reset Device Command
    pub const RESET_DEVICE: u32 = 17;
    /// Force Event Command (optional)
    pub const FORCE_EVENT: u32 = 18;
    /// Negotiate Bandwidth Command (optional)
    pub const NEGOTIATE_BANDWIDTH: u32 = 19;
    /// Set Latency Tolerance Value Command (optional)
    pub const SET_LATENCY_TOLERANCE: u32 = 20;
    /// Get Port Bandwidth Command (optional)
    pub const GET_PORT_BANDWIDTH: u32 = 21;
    /// Force Header Command
    pub const FORCE_HEADER: u32 = 22;
    /// No Op Command - No operation on command ring
    pub const NO_OP_CMD: u32 = 23;
    /// Get Extended Property Command (optional)
    pub const GET_EXTENDED_PROPERTY: u32 = 24;
    /// Set Extended Property Command (optional)
    pub const SET_EXTENDED_PROPERTY: u32 = 25;

    // Event TRBs (generated by xHC on Event Ring)
    /// Transfer Event - Completion of a transfer
    pub const TRANSFER_EVENT: u32 = 32;
    /// Command Completion Event
    pub const COMMAND_COMPLETION: u32 = 33;
    /// Port Status Change Event
    pub const PORT_STATUS_CHANGE: u32 = 34;
    /// Bandwidth Request Event (optional)
    pub const BANDWIDTH_REQUEST: u32 = 35;
    /// Doorbell Event (optional)
    pub const DOORBELL_EVENT: u32 = 36;
    /// Dma Controller Event
    pub const HOST_CONTROLLER_EVENT: u32 = 37;
    /// Device Notification Event
    pub const DEVICE_NOTIFICATION: u32 = 38;
    /// MFINDEX Wrap Event
    pub const MFINDEX_WRAP: u32 = 39;

    // Vendor-defined TRB types
    /// Vendor Defined Command
    pub const VENDOR_DEFINED_CMD: u32 = 48;
    /// Vendor Defined Event
    pub const VENDOR_DEFINED_EVENT: u32 = 49;
}

/// TRB completion codes as defined in the xHCI specification.
pub mod completion {
    /// Invalid - Not a valid completion code
    pub const INVALID: u8 = 0;
    /// Success - TRB completed without error
    pub const SUCCESS: u8 = 1;
    /// Data Buffer Error - Data buffer error
    pub const DATA_BUFFER_ERROR: u8 = 2;
    /// Babble Detected Error - Babble detected
    pub const BABBLE_DETECTED: u8 = 3;
    /// USB Transaction Error - USB transaction error
    pub const USB_TRANSACTION_ERROR: u8 = 4;
    /// TRB Error - TRB error
    pub const TRB_ERROR: u8 = 5;
    /// Stall Error - Endpoint stall
    pub const STALL_ERROR: u8 = 6;
    /// Resource Error - Inadequate xHC resources
    pub const RESOURCE_ERROR: u8 = 7;
    /// Bandwidth Error - Inadequate bandwidth
    pub const BANDWIDTH_ERROR: u8 = 8;
    /// No Slots Available Error - No device slots available
    pub const NO_SLOTS_AVAILABLE: u8 = 9;
    /// Invalid Stream Type Error - Invalid stream type
    pub const INVALID_STREAM_TYPE: u8 = 10;
    /// Slot Not Enabled Error - Slot not enabled
    pub const SLOT_NOT_ENABLED: u8 = 11;
    /// Endpoint Not Enabled Error - Endpoint not enabled
    pub const ENDPOINT_NOT_ENABLED: u8 = 12;
    /// Short Packet - Transfer completed with short packet
    pub const SHORT_PACKET: u8 = 13;
    /// Ring Underrun - Isoch transfer ring underrun
    pub const RING_UNDERRUN: u8 = 14;
    /// Ring Overrun - Isoch transfer ring overrun
    pub const RING_OVERRUN: u8 = 15;
    /// VF Event Ring Full Error - Virtual function event ring full
    pub const VF_EVENT_RING_FULL: u8 = 16;
    /// Parameter Error - Context parameter error
    pub const PARAMETER_ERROR: u8 = 17;
    /// Bandwidth Overrun Error - Isoch bandwidth overrun
    pub const BANDWIDTH_OVERRUN: u8 = 18;
    /// Context State Error - Context state error
    pub const CONTEXT_STATE_ERROR: u8 = 19;
    /// No Ping Response Error - No ping response
    pub const NO_PING_RESPONSE: u8 = 20;
    /// Event Ring Full Error - Event ring full
    pub const EVENT_RING_FULL: u8 = 21;
    /// Incompatible Device Error - Incompatible device
    pub const INCOMPATIBLE_DEVICE: u8 = 22;
    /// Missed Service Error - Missed service window
    pub const MISSED_SERVICE: u8 = 23;
    /// Command Ring Stopped - Command ring stopped
    pub const COMMAND_RING_STOPPED: u8 = 24;
    /// Command Aborted - Command aborted
    pub const COMMAND_ABORTED: u8 = 25;
    /// Stopped - Endpoint stopped
    pub const STOPPED: u8 = 26;
    /// Stopped - Length Invalid - Endpoint stopped with invalid length
    pub const STOPPED_LENGTH_INVALID: u8 = 27;
    /// Stopped - Short Packet - Endpoint stopped on short packet
    pub const STOPPED_SHORT_PACKET: u8 = 28;
    /// Max Exit Latency Too Large Error
    pub const MAX_EXIT_LATENCY_TOO_LARGE: u8 = 29;
    /// Isoch Buffer Overrun - Isoch buffer overrun
    pub const ISOCH_BUFFER_OVERRUN: u8 = 31;
    /// Event Lost Error - Event lost due to overflow
    pub const EVENT_LOST: u8 = 32;
    /// Undefined Error - Undefined error
    pub const UNDEFINED_ERROR: u8 = 33;
    /// Invalid Stream ID Error - Invalid stream ID
    pub const INVALID_STREAM_ID: u8 = 34;
    /// Secondary Bandwidth Error - Secondary bandwidth error
    pub const SECONDARY_BANDWIDTH_ERROR: u8 = 35;
    /// Split Transaction Error - Split transaction error
    pub const SPLIT_TRANSACTION_ERROR: u8 = 36;

    /// Returns a human-readable name for the completion code.
    pub const fn name(code: u8) -> &'static str {
        match code {
            SUCCESS => "Success",
            DATA_BUFFER_ERROR => "Data Buffer Error",
            BABBLE_DETECTED => "Babble Detected",
            USB_TRANSACTION_ERROR => "USB Transaction Error",
            TRB_ERROR => "TRB Error",
            STALL_ERROR => "Stall Error",
            RESOURCE_ERROR => "Resource Error",
            BANDWIDTH_ERROR => "Bandwidth Error",
            NO_SLOTS_AVAILABLE => "No Slots Available",
            INVALID_STREAM_TYPE => "Invalid Stream Type",
            SLOT_NOT_ENABLED => "Slot Not Enabled",
            ENDPOINT_NOT_ENABLED => "Endpoint Not Enabled",
            SHORT_PACKET => "Short Packet",
            RING_UNDERRUN => "Ring Underrun",
            RING_OVERRUN => "Ring Overrun",
            VF_EVENT_RING_FULL => "VF Event Ring Full",
            PARAMETER_ERROR => "Parameter Error",
            BANDWIDTH_OVERRUN => "Bandwidth Overrun",
            CONTEXT_STATE_ERROR => "Context State Error",
            NO_PING_RESPONSE => "No Ping Response",
            EVENT_RING_FULL => "Event Ring Full",
            INCOMPATIBLE_DEVICE => "Incompatible Device",
            MISSED_SERVICE => "Missed Service",
            COMMAND_RING_STOPPED => "Command Ring Stopped",
            COMMAND_ABORTED => "Command Aborted",
            STOPPED => "Stopped",
            STOPPED_LENGTH_INVALID => "Stopped - Length Invalid",
            STOPPED_SHORT_PACKET => "Stopped - Short Packet",
            MAX_EXIT_LATENCY_TOO_LARGE => "Max Exit Latency Too Large",
            ISOCH_BUFFER_OVERRUN => "Isoch Buffer Overrun",
            EVENT_LOST => "Event Lost",
            UNDEFINED_ERROR => "Undefined Error",
            INVALID_STREAM_ID => "Invalid Stream ID",
            SECONDARY_BANDWIDTH_ERROR => "Secondary Bandwidth Error",
            SPLIT_TRANSACTION_ERROR => "Split Transaction Error",
            _ => "Unknown",
        }
    }
}

/// TRB control field flags.
pub mod trb_flags {
    /// Cycle bit
    pub const CYCLE: u32 = 1 << 0;
    /// Evaluate Next TRB (ENT)
    pub const ENT: u32 = 1 << 1;
    /// Interrupt on Short Packet (ISP)
    pub const ISP: u32 = 1 << 2;
    /// No Snoop (NS)
    pub const NO_SNOOP: u32 = 1 << 3;
    /// Chain bit
    pub const CHAIN: u32 = 1 << 4;
    /// Interrupt on Completion (IOC)
    pub const IOC: u32 = 1 << 5;
    /// Immediate Data (IDT)
    pub const IDT: u32 = 1 << 6;
    /// Toggle Cycle (for Link TRB)
    pub const TOGGLE_CYCLE: u32 = 1 << 1;
    /// Block Event Interrupt (BEI)
    pub const BEI: u32 = 1 << 9;
}

/// Represents a DMA-capable physical memory region.
pub struct PhysMem<H: Dma> {
    addr: usize,
    size: usize,
    align: usize,
    _host: PhantomData<H>,
}

impl<H: Dma> PhysMem<H> {
    /// Allocates a new physical memory region with the specified alignment.
    pub fn alloc(host: &H, size: usize, align: usize) -> Result<Self> {
        let addr = unsafe { host.alloc(size, align) };
        if addr == 0 {
            return Err(UsbError::OoRam);
        }
        unsafe {
            core::ptr::write_bytes(addr as *mut u8, 0, size);
        }
        Ok(Self {
            addr,
            size,
            align,
            _host: PhantomData,
        })
    }

    /// Returns the virtual address.
    pub fn virt(&self) -> usize {
        self.addr
    }

    /// Returns the physical address.
    pub fn phys(&self, host: &H) -> u64 {
        host.virt_to_phys(self.addr) as u64
    }

    /// Returns a pointer to the memory.
    pub fn as_ptr<T>(&self) -> *mut T {
        self.addr as *mut T
    }

    /// Returns the size in bytes.
    pub fn size(&self) -> usize {
        self.size
    }

    /// Returns the alignment in bytes.
    pub fn align(&self) -> usize {
        self.align
    }

    /// Frees the memory region.
    pub fn free(self, host: &H) {
        unsafe {
            host.free(self.addr, self.size, self.align);
        }
        core::mem::forget(self);
    }
}

pub(crate) struct Ring<H: Dma> {
    mem: PhysMem<H>,
    enqueue: usize,
    cycle: bool,
    size: usize,
}

impl<H: Dma> Ring<H> {
    pub fn new(host: &H, trb_count: usize) -> Result<Self> {
        let mem = PhysMem::alloc(
            host,
            trb_count * core::mem::size_of::<Trb>(),
            core::mem::align_of::<Trb>(),
        )?;
        Ok(Self {
            mem,
            enqueue: 0,
            cycle: true,
            size: trb_count,
        })
    }

    pub fn phys(&self, host: &H) -> u64 {
        self.mem.phys(host)
    }

    fn trbs(&self) -> &mut [Trb] {
        unsafe { core::slice::from_raw_parts_mut(self.mem.as_ptr(), self.size) }
    }

    pub fn enqueue(&mut self, host: &H, mut trb: Trb) -> u64 {
        trb.set_cycle(self.cycle);
        let addr = self.mem.phys(host) + (self.enqueue * 16) as u64;
        self.trbs()[self.enqueue] = trb;
        self.enqueue += 1;

        if self.enqueue >= self.size - 1 {
            let mut link = Trb::new();
            link.param = self.mem.phys(host);
            link.control = (trb_type::LINK << 10) | 2;
            link.set_cycle(self.cycle);
            self.trbs()[self.enqueue] = link;
            self.enqueue = 0;
            self.cycle = !self.cycle;
        }

        addr
    }

    pub fn free(self, host: &H) {
        self.mem.free(host);
    }
}

#[repr(C, align(64))]
#[derive(Clone, Copy, Default)]
pub(crate) struct ErstEntry {
    pub base: u64,
    pub size: u16,
    _0: [u8; 6],
}

pub(crate) struct EventRing<H: Dma> {
    ring: PhysMem<H>,
    erst: PhysMem<H>,
    size: usize,
    dequeue: usize,
    cycle: bool,
}

impl<H: Dma> EventRing<H> {
    pub fn new(host: &H, trb_count: usize) -> Result<Self> {
        let ring = PhysMem::alloc(
            host,
            trb_count * core::mem::size_of::<Trb>(),
            core::mem::align_of::<Trb>(),
        )?;
        let erst = PhysMem::alloc(host, host.page_size(), core::mem::align_of::<ErstEntry>())?;

        let entry = erst.as_ptr::<ErstEntry>();
        unsafe {
            (*entry).base = ring.phys(host);
            (*entry).size = trb_count as u16;
        }

        Ok(Self {
            ring,
            erst,
            size: trb_count,
            dequeue: 0,
            cycle: true,
        })
    }

    pub fn ring_phys(&self, host: &H) -> u64 {
        self.ring.phys(host)
    }

    pub fn erst_phys(&self, host: &H) -> u64 {
        self.erst.phys(host)
    }

    pub fn try_dequeue(&mut self) -> Option<Trb> {
        let trb = unsafe {
            (self.ring.as_ptr::<Trb>())
                .add(self.dequeue)
                .read_volatile()
        };

        if trb.cycle() == self.cycle {
            self.dequeue += 1;
            if self.dequeue >= self.size {
                self.dequeue = 0;
                self.cycle = !self.cycle;
            }
            Some(trb)
        } else {
            None
        }
    }

    pub fn dequeue_ptr(&self, host: &H) -> u64 {
        self.ring.phys(host) + (self.dequeue * 16) as u64
    }
}
